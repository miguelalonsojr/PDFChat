<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ app_title }}</title>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <script src="https://unpkg.com/alpinejs@3.13.3/dist/cdn.min.js" defer></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Markdown and Syntax Highlighting -->
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/base16/solarized-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <style>
        /* Solarized Dark Color Palette */
        :root {
            --base03: #002b36;
            --base02: #073642;
            --base01: #586e75;
            --base00: #657b83;
            --base0: #839496;
            --base1: #93a1a1;
            --base2: #eee8d5;
            --base3: #fdf6e3;
            --yellow: #b58900;
            --orange: #cb4b16;
            --red: #dc322f;
            --magenta: #d33682;
            --violet: #6c71c4;
            --blue: #268bd2;
            --cyan: #2aa198;
            --green: #859900;
        }

        [x-cloak] { display: none !important; }

        html, body {
            height: 100%;
            margin: 0;
            overflow: hidden;
        }

        body {
            background-color: var(--base03);
            color: var(--base0);
            display: flex;
        }

        .main-layout {
            display: flex;
            width: 100%;
            height: 100vh;
        }

        .sidebar {
            width: 60px;
            background-color: var(--base02);
            border-right: 1px solid var(--base01);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem 0;
            gap: 1rem;
            flex-shrink: 0;
        }

        .sidebar-icon {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--base0);
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s;
            position: relative;
        }

        .sidebar-icon:hover {
            background-color: var(--base01);
            color: var(--cyan);
        }

        .sidebar-icon svg {
            width: 24px;
            height: 24px;
        }

        .flyout {
            position: absolute;
            left: 60px;
            top: 0;
            width: 300px;
            background-color: var(--base02);
            border: 1px solid var(--base01);
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            display: none;
            flex-direction: column;
            max-height: 400px;
            z-index: 1000;
        }

        .flyout.show {
            display: flex;
        }

        .flyout-header {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--base01);
            color: var(--base1);
            font-weight: 500;
        }

        .flyout-content {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
        }

        .flyout-item {
            padding: 0.75rem;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-bottom: 0.25rem;
        }

        .flyout-item:hover {
            background-color: var(--base01);
        }

        .flyout-item-title {
            color: var(--base1);
            font-size: 0.875rem;
            margin-bottom: 0.25rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .flyout-item-meta {
            color: var(--base00);
            font-size: 0.75rem;
        }

        .flyout-footer {
            padding: 0.75rem 1rem;
            border-top: 1px solid var(--base01);
            text-align: center;
        }

        .flyout-footer a {
            color: var(--cyan);
            text-decoration: none;
            font-size: 0.875rem;
        }

        .flyout-footer a:hover {
            color: var(--green);
        }

        .search-flyout {
            padding: 1rem;
        }

        .search-flyout input {
            width: 100%;
            background-color: var(--base03);
            border: 1px solid var(--base01);
            color: var(--base1);
            padding: 0.5rem;
            border-radius: 6px;
        }

        .search-flyout input:focus {
            outline: none;
            border-color: var(--cyan);
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
            flex: 1;
        }

        .header-section {
            flex-shrink: 0;
            padding: 1rem;
        }

        .chat-section {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            padding-bottom: 2rem;
            background-color: var(--base02);
        }

        .input-section {
            flex-shrink: 0;
            padding: 1rem;
            background-color: var(--base02);
            border-top: 1px solid var(--base01);
        }

        .message-content {
            word-wrap: break-word;
        }

        .chat-section::-webkit-scrollbar {
            width: 8px;
        }

        .chat-section::-webkit-scrollbar-track {
            background: var(--base03);
        }

        .chat-section::-webkit-scrollbar-thumb {
            background: var(--base01);
            border-radius: 4px;
        }

        .chat-section::-webkit-scrollbar-thumb:hover {
            background: var(--base00);
        }

        .card {
            background-color: var(--base02);
            border: 1px solid var(--base01);
        }

        .header-title {
            color: var(--base1);
        }

        .header-subtitle {
            color: var(--base0);
        }

        .user-message {
            background-color: var(--blue);
            color: var(--base03);
        }

        .assistant-message {
            background-color: var(--base02);
            color: var(--base1);
            border: 1px solid var(--base01);
        }

        .loading-bubble {
            background-color: var(--base01);
        }

        .loading-dot {
            background-color: var(--cyan);
        }

        .input-field {
            background-color: var(--base02);
            border: 1px solid var(--base01);
            color: var(--base1);
        }

        .input-field:focus {
            outline: none;
            border-color: var(--cyan);
            box-shadow: 0 0 0 2px rgba(42, 161, 152, 0.2);
        }

        .input-field:disabled {
            background-color: var(--base03);
            color: var(--base00);
        }

        .input-field::placeholder {
            color: var(--base00);
        }

        .btn-primary {
            background-color: var(--cyan);
            color: var(--base03);
            font-weight: 500;
        }

        .btn-primary:hover:not(:disabled) {
            background-color: var(--green);
        }

        .btn-primary:disabled {
            background-color: var(--base01);
            color: var(--base00);
            cursor: not-allowed;
        }

        .btn-reset {
            color: var(--base0);
        }

        .btn-reset:hover:not(:disabled) {
            color: var(--cyan);
        }

        .btn-reset:disabled {
            color: var(--base01);
        }

        .error-message {
            background-color: var(--base02);
            border: 1px solid var(--red);
            color: var(--red);
        }

        .empty-state-icon {
            color: var(--base01);
        }

        .empty-state-text {
            color: var(--base0);
        }

        .divider {
            border-color: var(--base01);
        }

        .thinking-box {
            background-color: var(--base03);
            border: 1px solid var(--base01);
            border-left: 3px solid var(--violet);
            margin: 0.5rem 0;
            border-radius: 4px;
            overflow: hidden;
        }

        .thinking-header {
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            user-select: none;
            color: var(--violet);
            font-size: 0.875rem;
            font-weight: 500;
        }

        .thinking-header:hover {
            background-color: var(--base02);
        }

        .thinking-chevron {
            transition: transform 0.2s;
            width: 1rem;
            height: 1rem;
        }

        .thinking-chevron.expanded {
            transform: rotate(90deg);
        }

        .thinking-content {
            padding: 0.75rem;
            color: var(--base0);
            font-size: 0.875rem;
            font-style: italic;
            border-top: 1px solid var(--base01);
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: 'Courier New', monospace;
        }

        .settings-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--base0);
            font-size: 0.875rem;
        }

        .toggle-checkbox {
            appearance: none;
            width: 2.5rem;
            height: 1.25rem;
            background-color: var(--base01);
            border-radius: 9999px;
            position: relative;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .toggle-checkbox:checked {
            background-color: var(--cyan);
        }

        .toggle-checkbox::before {
            content: '';
            position: absolute;
            width: 1rem;
            height: 1rem;
            background-color: var(--base2);
            border-radius: 50%;
            top: 0.125rem;
            left: 0.125rem;
            transition: transform 0.2s;
        }

        .toggle-checkbox:checked::before {
            transform: translateX(1.25rem);
        }

        /* Markdown Styles for Assistant Messages */
        .assistant-message h1,
        .assistant-message h2,
        .assistant-message h3,
        .assistant-message h4,
        .assistant-message h5,
        .assistant-message h6 {
            color: var(--cyan);
            font-weight: 600;
            margin-top: 1rem;
            margin-bottom: 0.5rem;
            line-height: 1.3;
        }

        .assistant-message h1 { font-size: 1.5rem; }
        .assistant-message h2 { font-size: 1.3rem; }
        .assistant-message h3 { font-size: 1.1rem; }
        .assistant-message h4 { font-size: 1rem; }

        .assistant-message p {
            margin: 0 0 0.75em 0;
            line-height: 1.4;
        }

        .assistant-message p:last-child {
            margin-bottom: 0;
        }

        .assistant-message ul {
            margin: 0.5em 0 0.75em 1.5rem;
            padding-left: 1.5rem;
            line-height: 1.3;
            list-style-type: disc;
        }

        .assistant-message ol {
            margin: 0.5em 0 0.75em 1.5rem;
            padding-left: 1.5rem;
            line-height: 1.3;
            list-style-type: decimal;
        }

        .assistant-message ul:last-child,
        .assistant-message ol:last-child {
            margin-bottom: 0;
        }

        .assistant-message li {
            margin: 0 0 0.3em 0;
            padding: 0;
        }

        .assistant-message li:last-child {
            margin-bottom: 0;
        }

        .assistant-message li p {
            margin: 0;
            display: inline;
        }

        .assistant-message code {
            background-color: var(--base03);
            color: var(--cyan);
            padding: 0.125rem 0.375rem;
            border-radius: 0.25rem;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
        }

        .assistant-message pre {
            background-color: var(--base03);
            border: 1px solid var(--base01);
            border-radius: 0.5rem;
            padding: 1rem;
            overflow-x: auto;
            margin-bottom: 0.75rem;
        }

        .assistant-message pre code {
            background-color: transparent;
            padding: 0;
            color: var(--base1);
        }

        .assistant-message blockquote {
            border-left: 4px solid var(--cyan);
            padding-left: 1rem;
            margin-left: 0;
            margin-bottom: 0.75rem;
            color: var(--base0);
            font-style: italic;
        }

        .assistant-message a {
            color: var(--blue);
            text-decoration: underline;
        }

        .assistant-message a:hover {
            color: var(--cyan);
        }

        .assistant-message hr {
            border: none;
            border-top: 1px solid var(--base01);
            margin: 1rem 0;
        }

        .assistant-message table {
            border-collapse: collapse;
            width: 100%;
            margin-bottom: 0.75rem;
        }

        .assistant-message th,
        .assistant-message td {
            border: 1px solid var(--base01);
            padding: 0.5rem;
            text-align: left;
        }

        .assistant-message th {
            background-color: var(--base03);
            color: var(--cyan);
            font-weight: 600;
        }

        .assistant-message strong {
            color: var(--base2);
            font-weight: 600;
        }

        .assistant-message em {
            color: var(--base1);
            font-style: italic;
        }
    </style>
</head>
<body x-data="chatApp()" x-cloak>
    <div class="main-layout">
        <!-- Sidebar -->
        <div class="sidebar">
            <!-- New Conversation Icon -->
            <div class="sidebar-icon"
                 @click="startNewConversation()"
                 title="New Conversation"
                 style="background-color: var(--cyan); color: var(--base03);">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/>
                </svg>
            </div>

            <!-- Search Icon -->
            <div class="sidebar-icon"
                 @mouseenter="showSearchFlyout = true; cancelHideSearchFlyout()"
                 @mouseleave="hideSearchFlyout()">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
                </svg>

                <!-- Search Flyout -->
                <div class="flyout search-flyout"
                     :class="{ 'show': showSearchFlyout }"
                     @mouseenter="showSearchFlyout = true; cancelHideSearchFlyout()"
                     @mouseleave="hideSearchFlyout()">
                    <input
                        type="text"
                        x-model="searchQuery"
                        @input="searchConversations()"
                        placeholder="Search conversations..."
                        @click.stop
                    >
                    <div class="flyout-content mt-2">
                        <template x-if="searchResults.length === 0 && searchQuery">
                            <div class="text-center py-4" style="color: var(--base00); font-size: 0.875rem;">
                                No results found
                            </div>
                        </template>
                        <template x-for="conv in searchResults" :key="conv.id">
                            <div class="flyout-item" @click="loadConversation(conv.id)">
                                <div class="flyout-item-title" x-text="conv.title"></div>
                                <div class="flyout-item-meta" x-text="formatDate(conv.updated_at)"></div>
                            </div>
                        </template>
                    </div>
                </div>
            </div>

            <!-- Chat History Icon -->
            <div class="sidebar-icon"
                 @mouseenter="showHistoryFlyout = true; cancelHideHistoryFlyout()"
                 @mouseleave="hideHistoryFlyout()">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
                </svg>

                <!-- History Flyout -->
                <div class="flyout"
                     :class="{ 'show': showHistoryFlyout }"
                     @mouseenter="showHistoryFlyout = true; cancelHideHistoryFlyout()"
                     @mouseleave="hideHistoryFlyout()">
                    <div class="flyout-header">Recent Conversations</div>
                    <div class="flyout-content">
                        <template x-if="recentConversations.length === 0">
                            <div class="text-center py-4" style="color: var(--base00); font-size: 0.875rem;">
                                No conversations yet
                            </div>
                        </template>
                        <template x-for="conv in recentConversations" :key="conv.id">
                            <div class="flyout-item" @click="loadConversation(conv.id)">
                                <div class="flyout-item-title" x-text="conv.title"></div>
                                <div class="flyout-item-meta" x-text="formatDate(conv.updated_at)"></div>
                            </div>
                        </template>
                    </div>
                    <div class="flyout-footer">
                        <a href="/history">View All</a>
                    </div>
                </div>
            </div>
        </div>

        <div class="app-container">
        <!-- Header Section (Sticky Top) -->
        <div class="header-section">
            <div class="card rounded-lg shadow-md p-6">
                <div class="flex justify-between items-start mb-2">
                    <div>
                        <h1 class="text-3xl font-bold header-title mb-2">{{ app_title }}</h1>
                        <p class="header-subtitle">{{ app_subtitle }}</p>
                    </div>
                    <div class="flex items-center gap-4">
                        <button
                            @click="startNewConversation()"
                            class="sidebar-icon"
                            title="New Conversation"
                            style="background-color: var(--cyan); color: var(--base03);"
                        >
                            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/>
                            </svg>
                        </button>
                        <div class="settings-toggle">
                            <label class="flex items-center gap-2 cursor-pointer">
                                <span>Show thinking</span>
                                <input
                                    type="checkbox"
                                    x-model="showThinking"
                                    class="toggle-checkbox"
                                >
                            </label>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Chat Section (Scrollable Middle) -->
        <div class="chat-section space-y-4" x-ref="chatContainer">
                <template x-if="messages.length === 0">
                    <div class="text-center py-12">
                        <svg class="mx-auto h-12 w-12 empty-state-icon mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z"/>
                        </svg>
                        <p class="text-lg empty-state-text">Start a conversation about your documents</p>
                    </div>
                </template>

                <template x-for="(msg, index) in messages" :key="index">
                    <div :class="msg.role === 'user' ? 'flex justify-end' : 'flex justify-start'">
                        <div :class="msg.role === 'user'
                            ? 'user-message rounded-lg px-4 py-2 max-w-xl'
                            : 'assistant-message rounded-lg px-4 py-2 w-full'">
                            <div class="message-content" x-html="renderMessage(msg.content, index)"></div>
                        </div>
                    </div>
                </template>

                <!-- Loading indicator -->
                <template x-if="isLoading">
                    <div class="flex justify-start">
                        <div class="loading-bubble rounded-lg px-4 py-2">
                            <div class="flex space-x-2">
                                <div class="w-2 h-2 loading-dot rounded-full animate-bounce"></div>
                                <div class="w-2 h-2 loading-dot rounded-full animate-bounce" style="animation-delay: 0.1s"></div>
                                <div class="w-2 h-2 loading-dot rounded-full animate-bounce" style="animation-delay: 0.2s"></div>
                            </div>
                        </div>
                    </div>
                </template>
        </div>

        <!-- Input Section (Sticky Bottom) -->
        <div class="input-section">
            <form @submit.prevent="sendMessage()" class="flex space-x-2">
                <input
                    type="text"
                    x-model="currentMessage"
                    :disabled="isLoading"
                    placeholder="Ask a question about your PDFs..."
                    class="flex-1 input-field rounded-lg px-4 py-2"
                >
                <button
                    type="submit"
                    :disabled="isLoading || !currentMessage.trim()"
                    class="btn-primary px-6 py-2 rounded-lg transition-colors"
                >
                    Send
                </button>
            </form>

            <!-- Reset button and error messages -->
            <div class="mt-2 flex justify-between items-center">
                <div x-show="error" class="error-message px-4 py-2 rounded-lg flex-1 mr-2">
                    <p x-text="error" class="text-sm"></p>
                </div>
                <button
                    @click="resetChat()"
                    :disabled="isLoading"
                    class="text-sm btn-reset whitespace-nowrap"
                >
                    Reset conversation
                </button>
            </div>
        </div>
        </div>
    </div>

    <script>
        function chatApp() {
            return {
                messages: [],
                currentMessage: '',
                isLoading: false,
                error: '',
                showThinking: false,
                thinkingExpanded: {},

                // Conversation management
                currentConversationId: null,
                recentConversations: [],
                searchQuery: '',
                searchResults: [],
                showHistoryFlyout: false,
                showSearchFlyout: false,
                historyFlyoutTimeout: null,
                searchFlyoutTimeout: null,
                searchTimeout: null,

                async init() {
                    // Configure marked.js with highlight.js for syntax highlighting
                    if (typeof marked !== 'undefined') {
                        const renderer = new marked.Renderer();
                        const originalCodeRenderer = renderer.code.bind(renderer);
                        const originalLinkRenderer = renderer.link.bind(renderer);

                        renderer.code = function(code, language) {
                            // Let marked generate the default code block structure
                            const html = originalCodeRenderer(code, language);
                            return html;
                        };

                        renderer.link = function(href, title, text) {
                            // Add target="_blank" to all links
                            const html = originalLinkRenderer(href, title, text);
                            return html.replace('<a ', '<a target="_blank" ');
                        };

                        marked.setOptions({
                            renderer: renderer,
                            breaks: true,
                            gfm: true,
                            pedantic: false
                        });
                    }

                    // Check if we should load a specific conversation
                    const urlParams = new URLSearchParams(window.location.search);
                    const conversationId = urlParams.get('conversation');

                    if (conversationId) {
                        await this.loadConversation(parseInt(conversationId));
                    }
                    // Don't create a new conversation until we have messages to save

                    // Load recent conversations for the flyout
                    await this.loadRecentConversations();
                },

                async createNewConversation() {
                    try {
                        const response = await fetch('/api/conversations', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ title: 'New Conversation' })
                        });

                        if (response.ok) {
                            const data = await response.json();
                            this.currentConversationId = data.id;
                        }
                    } catch (err) {
                        console.error('Error creating conversation:', err);
                    }
                },

                async loadRecentConversations() {
                    try {
                        const response = await fetch('/api/conversations/recent?limit=10');
                        if (response.ok) {
                            this.recentConversations = await response.json();
                        }
                    } catch (err) {
                        console.error('Error loading recent conversations:', err);
                    }
                },

                async loadConversation(conversationId) {
                    try {
                        const response = await fetch(`/api/conversations/${conversationId}`);
                        if (response.ok) {
                            const conversation = await response.json();
                            this.currentConversationId = conversationId;
                            this.messages = conversation.messages || [];

                            // Update URL without page reload
                            const url = new URL(window.location);
                            url.searchParams.set('conversation', conversationId);
                            window.history.pushState({}, '', url);

                            this.scrollToBottom();
                            this.hideHistoryFlyout();
                            this.hideSearchFlyout();
                        }
                    } catch (err) {
                        console.error('Error loading conversation:', err);
                        this.error = 'Failed to load conversation';
                    }
                },

                async searchConversations() {
                    clearTimeout(this.searchTimeout);
                    this.searchTimeout = setTimeout(async () => {
                        if (!this.searchQuery.trim()) {
                            this.searchResults = [];
                            return;
                        }

                        try {
                            const response = await fetch(`/api/conversations/search?q=${encodeURIComponent(this.searchQuery)}`);
                            if (response.ok) {
                                this.searchResults = await response.json();
                            }
                        } catch (err) {
                            console.error('Error searching conversations:', err);
                        }
                    }, 300);
                },

                async saveConversation(userMessage, assistantMessage) {
                    try {
                        // Create conversation if it doesn't exist
                        if (!this.currentConversationId) {
                            await this.createNewConversation();
                        }

                        if (!this.currentConversationId) {
                            console.error('Failed to create conversation');
                            return;
                        }

                        // Save user message
                        await fetch(`/api/conversations/${this.currentConversationId}/messages`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ role: 'user', content: userMessage })
                        });

                        // Save assistant message
                        await fetch(`/api/conversations/${this.currentConversationId}/messages`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ role: 'assistant', content: assistantMessage })
                        });

                        // Generate title after first exchange
                        if (this.messages.length <= 2) {
                            await this.generateConversationTitle();
                        }

                        // Refresh recent conversations
                        await this.loadRecentConversations();

                        // Update URL with conversation ID if not already set
                        const urlParams = new URLSearchParams(window.location.search);
                        if (!urlParams.get('conversation')) {
                            const url = new URL(window.location);
                            url.searchParams.set('conversation', this.currentConversationId);
                            window.history.pushState({}, '', url);
                        }
                    } catch (err) {
                        console.error('Error saving conversation:', err);
                    }
                },

                async generateConversationTitle() {
                    if (!this.currentConversationId) return;

                    try {
                        const response = await fetch(`/api/conversations/${this.currentConversationId}/title`, {
                            method: 'POST'
                        });

                        if (response.ok) {
                            const data = await response.json();
                            await this.loadRecentConversations();
                        }
                    } catch (err) {
                        console.error('Error generating title:', err);
                    }
                },

                startNewConversation() {
                    // Clear current conversation and reload page
                    window.location.href = '/';
                },

                hideHistoryFlyout() {
                    clearTimeout(this.historyFlyoutTimeout);
                    this.historyFlyoutTimeout = setTimeout(() => {
                        this.showHistoryFlyout = false;
                    }, 300);
                },

                hideSearchFlyout() {
                    clearTimeout(this.searchFlyoutTimeout);
                    this.searchFlyoutTimeout = setTimeout(() => {
                        this.showSearchFlyout = false;
                    }, 300);
                },

                cancelHideHistoryFlyout() {
                    clearTimeout(this.historyFlyoutTimeout);
                },

                cancelHideSearchFlyout() {
                    clearTimeout(this.searchFlyoutTimeout);
                },

                formatDate(dateString) {
                    const date = new Date(dateString);
                    const now = new Date();
                    const diffMs = now - date;
                    const diffMins = Math.floor(diffMs / 60000);
                    const diffHours = Math.floor(diffMs / 3600000);
                    const diffDays = Math.floor(diffMs / 86400000);

                    if (diffMins < 1) return 'Just now';
                    if (diffMins < 60) return `${diffMins} min ago`;
                    if (diffHours < 24) return `${diffHours}h ago`;
                    if (diffDays < 7) return `${diffDays}d ago`;

                    return date.toLocaleDateString();
                },

                async sendMessage() {
                    if (!this.currentMessage.trim() || this.isLoading) return;

                    const userMessage = this.currentMessage.trim();
                    this.currentMessage = '';
                    this.error = '';

                    // Add user message
                    this.messages.push({
                        role: 'user',
                        content: userMessage
                    });

                    this.scrollToBottom();
                    this.isLoading = true;

                    try {
                        // Call streaming API
                        const response = await fetch('/api/chat', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ message: userMessage })
                        });

                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }

                        // Read streaming response
                        const reader = response.body.getReader();
                        const decoder = new TextDecoder();

                        // Add assistant message placeholder
                        this.messages.push({
                            role: 'assistant',
                            content: '',
                            rawContent: ''
                        });

                        const assistantMessageIndex = this.messages.length - 1;
                        let buffer = '';
                        let insideThinkTag = false;
                        let thinkingBuffer = '';
                        let finalContent = '';
                        let thinkingPlaceholderId = 0;
                        const placeholderMap = new Map(); // Maps placeholder ID to thinking content

                        const funnyThinkingMessages = [
                            'ðŸ¤” Consulting the ancient PDFs...',
                            'ðŸ§  Activating neural pathways...',
                            'ðŸ“š Flipping through digital pages...',
                            'ðŸ” Searching for wisdom in the bytes...',
                            'ðŸ’­ Pondering the great questions...',
                            'ðŸŽ¯ Aiming for accuracy...',
                            'âš¡ Charging up the knowledge banks...',
                            'ðŸŒŸ Channeling document energy...',
                            'ðŸŽ¨ Painting a picture with words...',
                            'ðŸš€ Launching brain rockets...',
                            'ðŸ”® Divining answers from the void...',
                            'ðŸ§™ Casting knowledge spells...',
                            'ðŸŽª Juggling information...',
                            'ðŸŒŠ Swimming through data streams...',
                            'ðŸŽ­ Rehearsing the perfect response...'
                        ];

                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;

                            const chunk = decoder.decode(value);
                            buffer += chunk;

                            // Process buffer for <think> tags
                            while (true) {
                                if (!insideThinkTag) {
                                    const thinkStart = buffer.indexOf('<think>');
                                    if (thinkStart === -1) {
                                        // No think tag, add rest of buffer to content and clear buffer
                                        finalContent += buffer;
                                        buffer = '';
                                        break;
                                    } else {
                                        // Found think tag start
                                        finalContent += buffer.substring(0, thinkStart);
                                        insideThinkTag = true;
                                        thinkingBuffer = '';
                                        buffer = buffer.substring(thinkStart + 7); // Remove '<think>' from buffer

                                        // Add funny placeholder as a temporary tag
                                        const funnyMessage = funnyThinkingMessages[Math.floor(Math.random() * funnyThinkingMessages.length)];
                                        const placeholderId = `THINKID${thinkingPlaceholderId}`;
                                        thinkingPlaceholderId++;

                                        placeholderMap.set(placeholderId, { funny: funnyMessage, content: null });
                                        finalContent += `<thinking-temp id="${placeholderId}">${funnyMessage}</thinking-temp>`;
                                    }
                                } else {
                                    const thinkEnd = buffer.indexOf('</think>');
                                    if (thinkEnd === -1) {
                                        // No end tag yet, buffer the thinking content
                                        thinkingBuffer += buffer;
                                        buffer = '';
                                        break;
                                    } else {
                                        // Found end tag
                                        thinkingBuffer += buffer.substring(0, thinkEnd);
                                        insideThinkTag = false;
                                        buffer = buffer.substring(thinkEnd + 8); // Remove '</think>' from buffer

                                        // Find the placeholder and replace it with the thinking block
                                        const placeholderId = `THINKID${thinkingPlaceholderId - 1}`;
                                        const thinkBlock = `<think>${thinkingBuffer}</think>`;

                                        // Replace the temporary thinking tag with the actual thinking block
                                        const tempTagRegex = new RegExp(`<thinking-temp id="${placeholderId}">.*?</thinking-temp>`, 's');
                                        finalContent = finalContent.replace(tempTagRegex, thinkBlock);

                                        thinkingBuffer = '';
                                        // Continue processing in case there are more tags
                                    }
                                }
                            }

                            // Update message content
                            this.messages[assistantMessageIndex].content = finalContent;
                            this.scrollToBottom();
                        }

                        // Save the complete conversation exchange (user + assistant) to database
                        await this.saveConversation(userMessage, finalContent);

                    } catch (err) {
                        this.error = `Error: ${err.message}. Make sure the server is running and the index is built.`;
                        console.error('Error:', err);
                    } finally {
                        this.isLoading = false;
                    }
                },

                async resetChat() {
                    if (!confirm('Are you sure you want to reset the conversation?')) return;

                    try {
                        const response = await fetch('/api/reset', {
                            method: 'POST'
                        });

                        if (response.ok) {
                            this.messages = [];
                            this.error = '';
                        }
                    } catch (err) {
                        this.error = `Error resetting chat: ${err.message}`;
                    }
                },

                scrollToBottom() {
                    this.$nextTick(() => {
                        const container = this.$refs.chatContainer;
                        container.scrollTop = container.scrollHeight;

                        // Highlight code blocks after rendering
                        if (typeof hljs !== 'undefined') {
                            container.querySelectorAll('pre code').forEach((block) => {
                                hljs.highlightElement(block);
                            });
                        }
                    });
                },

                escapeHtml(text) {
                    const div = document.createElement('div');
                    div.textContent = text;
                    return div.innerHTML;
                },

                parseMarkdown(text) {
                    // If marked is available, parse as markdown, otherwise escape HTML
                    if (typeof marked !== 'undefined') {
                        try {
                            return marked.parse(text);
                        } catch (err) {
                            console.error('Markdown parsing error:', err);
                            return this.escapeHtml(text);
                        }
                    }
                    return this.escapeHtml(text);
                },

                renderMessage(content, messageIndex) {
                    if (!content) return '';

                    let processedContent = content;
                    let html = '';
                    let lastIndex = 0;

                    // Combined regex to match both <thinking-temp> and <think> tags
                    const combinedRegex = /(<thinking-temp[^>]*>[\s\S]*?<\/thinking-temp>)|(<think>[\s\S]*?<\/think>)/g;
                    let match;
                    let thinkingIndex = 0;

                    while ((match = combinedRegex.exec(processedContent)) !== null) {
                        // Add text before the thinking block
                        if (match.index > lastIndex) {
                            const textBefore = processedContent.substring(lastIndex, match.index);
                            html += this.parseMarkdown(textBefore);
                        }

                        if (match[1]) {
                            // This is a <thinking-temp> tag (still thinking)
                            // ALWAYS show the funny message, regardless of toggle state
                            const tempContent = match[1].match(/<thinking-temp[^>]*>([\s\S]*?)<\/thinking-temp>/);
                            if (tempContent) {
                                const funnyMessage = tempContent[1];
                                html += `<span style="color: var(--violet); font-style: italic;">${this.escapeHtml(funnyMessage)}</span>`;
                            }
                        } else if (match[2]) {
                            // This is a <think> tag (thinking complete)
                            // Only show if toggle is ON
                            if (this.showThinking) {
                                const thinkContent = match[2].match(/<think>([\s\S]*?)<\/think>/);
                                if (thinkContent) {
                                    const thinkingContent = thinkContent[1];
                                    const thinkingId = `think-${messageIndex}-${thinkingIndex}`;
                                    const isExpanded = this.thinkingExpanded[thinkingId] || false;
                                    const escapedThinking = this.escapeHtml(thinkingContent);

                                    html += `
                                        <div class="thinking-box">
                                            <div class="thinking-header" data-thinking-id="${thinkingId}">
                                                <svg class="thinking-chevron ${isExpanded ? 'expanded' : ''}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                                                </svg>
                                                <span>Thinking trace</span>
                                            </div>
                                            <div class="thinking-content" style="display: ${isExpanded ? 'block' : 'none'}" id="${thinkingId}">${escapedThinking}</div>
                                        </div>
                                    `;

                                    thinkingIndex++;
                                }
                            }
                            // If toggle is OFF, the <think> block is simply not rendered (skipped)
                        }

                        lastIndex = match.index + match[0].length;
                    }

                    // Add remaining text after last thinking block
                    if (lastIndex < processedContent.length) {
                        const remainingText = processedContent.substring(lastIndex);
                        html += this.parseMarkdown(remainingText);
                    }

                    return html || this.parseMarkdown(processedContent);
                },

                toggleThinking(thinkingId) {
                    this.thinkingExpanded[thinkingId] = !this.thinkingExpanded[thinkingId];

                    // Update DOM
                    const contentEl = document.getElementById(thinkingId);
                    const chevronEl = contentEl?.previousElementSibling?.querySelector('.thinking-chevron');

                    if (contentEl) {
                        contentEl.style.display = this.thinkingExpanded[thinkingId] ? 'block' : 'none';
                    }

                    if (chevronEl) {
                        if (this.thinkingExpanded[thinkingId]) {
                            chevronEl.classList.add('expanded');
                        } else {
                            chevronEl.classList.remove('expanded');
                        }
                    }
                }
            }
        }

        // Setup click handlers for thinking boxes
        document.addEventListener('click', (e) => {
            const header = e.target.closest('.thinking-header');
            if (header && header.dataset.thinkingId) {
                const thinkingId = header.dataset.thinkingId;
                const appContainer = document.querySelector('[x-data="chatApp()"]');

                // Try to get Alpine instance and call toggleThinking
                if (appContainer && typeof Alpine !== 'undefined') {
                    const app = Alpine.$data(appContainer);
                    if (app && typeof app.toggleThinking === 'function') {
                        app.toggleThinking(thinkingId);
                    }
                } else {
                    // Fallback: manually toggle without Alpine state tracking
                    const contentEl = document.getElementById(thinkingId);
                    const chevronEl = header.querySelector('.thinking-chevron');

                    if (contentEl) {
                        const isCurrentlyHidden = contentEl.style.display === 'none' || contentEl.style.display === '';
                        contentEl.style.display = isCurrentlyHidden ? 'block' : 'none';

                        if (chevronEl) {
                            if (isCurrentlyHidden) {
                                chevronEl.classList.add('expanded');
                            } else {
                                chevronEl.classList.remove('expanded');
                            }
                        }
                    }
                }
            }
        });
    </script>
</body>
</html>
